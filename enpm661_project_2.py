# -*- coding: utf-8 -*-
"""ENPM661-PROJECT-2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gGwy8TeUpw66YE_moKvLIxVGiarn5FzR
"""

import numpy as np
import matplotlib.pyplot as plt
import time
from queue import PriorityQueue
from matplotlib.animation import FuncAnimation

class Vertex:
    def __init__(self, x_coord, y_coord, cost, parent_vertex):
        self.x_coord = x_coord
        self.y_coord = y_coord
        self.cost = cost
        self.parent_vertex = parent_vertex

    def __lt__(self, other):
        return self.cost < other.cost

def move_up(x, y, cost):
    return x, y + 1, cost + 1

def move_down(x, y, cost):
    return x, y - 1, cost + 1

def move_left(x, y, cost):
    return x - 1, y, cost + 1

def move_right(x, y, cost):
    return x + 1, y, cost + 1

def move_upright(x, y, cost):
    return x + 1, y + 1, cost + np.sqrt(2)

def move_downright(x, y, cost):
    return x + 1, y - 1, cost + np.sqrt(2)

def move_upleft(x, y, cost):
    return x - 1, y + 1, cost + np.sqrt(2)

def move_downleft(x, y, cost):
    return x - 1, y - 1, cost + np.sqrt(2)


def move_vertex(move, x_coord, y_coord, cost):
    if move == 'Up':
        return move_up(x_coord, y_coord, cost)
    elif move == 'UpRight':
        return move_upright(x_coord, y_coord, cost)
    elif move == 'Right':
        return move_right(x_coord, y_coord, cost)
    elif move == 'DownRight':
        return move_downright(x_coord, y_coord, cost)
    elif move == 'Down':
        return move_down(x_coord, y_coord, cost)
    elif move == 'DownLeft':
        return move_downleft(x_coord, y_coord, cost)
    elif move == 'Left':
        return move_left(x_coord, y_coord, cost)
    elif move == 'UpLeft':
        return move_upleft(x_coord, y_coord, cost)
    else:
        return None

def create_shape_map(width, height):
    shape_map = np.full((height, width), 0)
    for y_coord in range(0, height):
        for x_coord in range(0, width):
            rect_1_1_temp = (x_coord + 5) - 100
            rect_1_2_temp = (y_coord + 5) - 100
            rect_1_3_temp = (x_coord - 5) - 175
            rect__4_temp = (y_coord - 5) - 500

            recta_2_1_temp = (x_coord + 5) - 275
            recta_2_2_temp = (y_coord + 5) - 0
            recta_2_3_temp = (x_coord - 5) - 350
            recta_2_4_temp = (y_coord - 5) - 400

            hexagon_size_6_temp = (y_coord + 5) +  0.58*(x_coord + 5) - 475.098
            hexagon_size_5_temp = (y_coord + 5) - 0.58*(x_coord - 5) + 275.002
            hexagon_size_4_temp = (x_coord - 6.5) - 779.9
            hexagon_size_3_temp = (y_coord - 5) + 0.58*(x_coord - 5) - 775.002
            hexagon_size_2_temp = (y_coord - 5) - 0.58*(x_coord + 5) - 24.92
            hexagon_size_1_temp = (x_coord + 6.5) - 520.1

            trap_a_temp = (x_coord + 5) - 900
            trap_b_temp = (x_coord + 5) - 1020
            trap_c_temp = (x_coord - 5) - 1100
            trap_d_temp = (y_coord + 5) - 50
            trap_e_temp = (y_coord - 5) - 125
            trap_f_temp = (y_coord + 5) - 375
            trap_g_temp = (y_coord - 5) - 450

            if((trap_a_temp > 0 and trap_b_temp < 0 and trap_d_temp > 0 and trap_e_temp < 0) or (trap_b_temp > 0 and trap_c_temp < 0 and trap_d_temp > 0 and trap_g_temp < 0) or (trap_f_temp > 0 and trap_g_temp < 0 and trap_a_temp > 0 and trap_b_temp < 0) or (rect_1_1_temp > 0 and rect_1_2_temp > 0 and rect_1_3_temp < 0 and rect__4_temp < 0) or (recta_2_1_temp > 0 and recta_2_3_temp < 0 and recta_2_4_temp < 0 and recta_2_2_temp > 0) or (hexagon_size_6_temp > 0 and hexagon_size_5_temp > 0 and hexagon_size_4_temp < 0 and hexagon_size_3_temp < 0 and hexagon_size_2_temp < 0 and hexagon_size_1_temp > 0)):
                shape_map[y_coord, x_coord] = 1

            w1_temp = (y_coord) - 5
            w2_temp = (y_coord) - 495
            w3_temp = (x_coord) - 5
            w4_temp = (x_coord) - 1195

            rect_1_1 = (x_coord) - 100
            rect_1_2 = (y_coord) - 100
            rect_1_3 = (x_coord) - 175
            rect__4 = (y_coord) - 500

            recta_2_1 = (x_coord) - 275
            recta_2_2 = (y_coord) - 0
            recta_2_4 = (x_coord) - 350
            recta_2_3 = (y_coord) - 400

            hexagon_size_6 = (y_coord) +  0.58*(x_coord) - 475.098
            hexagon_size_5 = (y_coord) - 0.58*(x_coord) + 275.002
            hexagon_size_4 = (x_coord) - 779.9
            hexagon_size_3 = (y_coord) + 0.58*(x_coord) - 775.002
            hexagon_size_2 = (y_coord) - 0.58*(x_coord) - 24.92
            hexagon_size_1 = (x_coord) - 520.1

            trap_a = (x_coord) - 900
            trap_b = (x_coord) - 1020
            trap_c = (x_coord) - 1100
            trap_d = (y_coord) - 50
            trap_e = (y_coord) - 125
            trap_f = (y_coord) - 375
            trap_g = (y_coord) - 450

            if((hexagon_size_6 > 0 and hexagon_size_5 > 0 and hexagon_size_4 < 0 and hexagon_size_3 < 0 and hexagon_size_2 < 0 and hexagon_size_1 > 0) or (rect_1_1 > 0 and rect_1_2 > 0 and rect_1_3 < 0 and rect__4 < 0 ) or (recta_2_1 > 0  and recta_2_3 < 0 and recta_2_4 < 0 and recta_2_2 > 0) or (trap_a > 0 and trap_b < 0 and trap_d > 0 and trap_e < 0) or (trap_b > 0 and trap_c < 0 and trap_d > 0 and trap_g < 0) or (trap_f > 0 and trap_g < 0 and trap_a > 0 and trap_b < 0) or (w1_temp < 0) or (w2_temp > 0) or (w3_temp < 0) or (w4_temp > 0)):
                shape_map[y_coord, x_coord] = 2

    return shape_map


def is_goal_reached(current, goal):
    if (current.x_coord == goal.x_coord) and (current.y_coord == goal.y_coord):
        return True
    else:
        return False

def is_valid_move(x, y, shape_map):
    size = shape_map.shape
    if(x >= size[1] or x < 0 or y >= size[0] or y < 0) or (shape_map[y][x] == 1) or (shape_map[y][x] == 2):
        return False
    return True

def generate_unique_id(vertex):
    id = 3333*vertex.x_coord + 113*vertex.y_coord
    return id

def find_shortest_path(start, goal, shape_map):
    if start.x_coord == goal.x_coord and start.y_coord == goal.y_coord:
        return None, 1

    goal_vertex = goal
    start_vertex = start
    unexplored_vertices = {}
    all_vertices = []
    explored_vertices = {}
    open_queue = PriorityQueue()
    possible_moves = ['Up', 'UpRight', 'Right', 'DownRight', 'Down', 'DownLeft', 'Left', 'UpLeft']

    start_key = generate_unique_id(start_vertex)
    unexplored_vertices[start_key] = start_vertex
    open_queue.put((start_vertex.cost, start_vertex))

    while not open_queue.empty():
        current_vertex = open_queue.get()[1]
        all_vertices.append([current_vertex.x_coord, current_vertex.y_coord])
        current_id = generate_unique_id(current_vertex)

        if current_vertex.x_coord == goal_vertex.x_coord and current_vertex.y_coord == goal_vertex.y_coord:
            goal_vertex.parent_vertex = current_vertex.parent_vertex
            goal_vertex.cost = current_vertex.cost
            print("Goal Vertex found")
            return all_vertices, 1

        if current_id in explored_vertices:
            continue
        else:
            explored_vertices[current_id] = current_vertex

        del unexplored_vertices[current_id]

        for move in possible_moves:
            x, y, cost = move_vertex(move, current_vertex.x_coord, current_vertex.y_coord, current_vertex.cost)
            new_vertex = Vertex(x, y, cost, current_vertex)
            new_vertex_id = generate_unique_id(new_vertex)

            if not is_valid_move(new_vertex.x_coord, new_vertex.y_coord, shape_map) or new_vertex_id in explored_vertices:
                continue

            if new_vertex_id in unexplored_vertices:
                if new_vertex.cost < unexplored_vertices[new_vertex_id].cost:
                    unexplored_vertices[new_vertex_id].cost = new_vertex.cost
                    unexplored_vertices[new_vertex_id].parent_vertex = new_vertex.parent_vertex
            else:
                unexplored_vertices[new_vertex_id] = new_vertex

            open_queue.put((new_vertex.cost, new_vertex))

    return all_vertices, 0

def backtrack_path(goal_vertex):
    backtrack_stack = []
    backtrack_stack.append(goal_vertex)
    while backtrack_stack[-1].parent_vertex != -1:
        parent = backtrack_stack[-1].parent_vertex
        backtrack_stack.append(parent)
    backtrack_stack.reverse()
    x_path = [vertex.x_coord for vertex in backtrack_stack]
    y_path = [vertex.y_coord for vertex in backtrack_stack]
    return x_path, y_path


class Plotter:
    def __init__(self, start_vertex, goal_vertex, shape_map):
        self.start_vertex = start_vertex
        self.goal_vertex = goal_vertex
        self.shape_map = shape_map

        # Plot the Start and Goal Positions
        plt.plot(start_vertex.x_coord, start_vertex.y_coord, "Db")
        plt.plot(goal_vertex.x_coord, goal_vertex.y_coord, "Dg")

        # Plot Map
        plt.imshow(shape_map, cmap='binary')  # Set unexplored area to black
        self.ax = plt.gca()
        self.ax.invert_yaxis()
        self.explored_vertices = []
        self.explored_batch_size = 5000

    def plot_explored_vertices(self, explored_vertices):
        self.explored_vertices.extend(explored_vertices)
        if len(self.explored_vertices) >= self.explored_batch_size:
            self.plot_batch()

    def plot_batch(self):
        explored_array = np.array(self.explored_vertices)
        x_coords, y_coords = explored_array[:, 0], explored_array[:, 1]
        plt.plot(x_coords, y_coords, "mp")  # Set explored area to pink
        self.explored_vertices = []

    def plot_path(self, x_path, y_path):
        plt.plot(x_path, y_path, "--b")  # Set obstacle color to blue
        plt.show()
        plt.close('all')

    def animate_exploration_and_path(self, explored_vertices, x_path, y_path):
        fig, ax = plt.subplots()

        # Plot the exploration
        ax.imshow(self.shape_map, cmap='binary')
        explored_line, = ax.plot([], [], 'y3')  # Explored vertices line
        path_line, = ax.plot([], [], 'b-')      # Path line

        # Set up the axes properties
        ax.set_xlim(0, self.shape_map.shape[1])
        ax.set_ylim(0, self.shape_map.shape[0])

        def update(frame):
            # Update the data for explored vertices up to current frame
            explored_line.set_data([node[0] for node in explored_vertices[:frame+1]],
                                    [node[1] for node in explored_vertices[:frame+1]])

            # Update the data for the path up to current frame
            path_line.set_data(x_path[:frame+1], y_path[:frame+1])

            return explored_line, path_line

        # Create the animation
        ani = FuncAnimation(fig, update, frames=len(x_path), interval=2, blit=True)

        plt.show()

if __name__ == '__main__':
    width = 1200
    height = 500
    shape_map = create_shape_map(width, height)
    start_x = int(input("Enter Start X: "))
    start_y = int(input("Enter Start Y: "))
    goal_x = int(input("Enter Goal X: "))
    goal_y = int(input("Enter Goal Y: "))
    start_time = time.time()
    if not is_valid_move(start_x, start_y, shape_map):
        print("Enter Start vertex within the permitted Space")
        exit(-1)
    if not is_valid_move(goal_x, goal_y, shape_map):
        print("Put goal vertex within the permitted Space")
        exit(-1)

    start_vertex = Vertex(start_x, start_y, 0.0, -1)
    goal_vertex = Vertex(goal_x, goal_y, 0.0, -1)

    explored_vertices, goal_status = find_shortest_path(start_vertex, goal_vertex, shape_map)
    if goal_status == 1:
        x_path, y_path = backtrack_path(goal_vertex)
        plotter_explored = Plotter(start_vertex, goal_vertex, shape_map)
        plotter_path = Plotter(start_vertex, goal_vertex, shape_map)

        plotter_explored.plot_explored_vertices(explored_vertices)
        plotter_path.plot_path(x_path, y_path)

        if x_path and y_path:  # Check if paths are not empty
            plotter_explored.animate_exploration_and_path(explored_vertices, x_path, y_path)
            plotter_path.animate_exploration_and_path([], [], [])  # No need for explored vertices here

        cost = goal_vertex.cost
        print(f"Cost to goal: {cost:.2f}")
    else:
        print("Goal not be planned for points")
    end_time = time.time()
    print(f"Time to execute the program: {end_time - start_time}")